<!DOCTYPE html>
<html>
<head>
    <title>three.js webgl - water - foam</title>
    <meta charset="utf-8" />
    <meta
            name="viewport"
            content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link
            type="text/css"
            rel="stylesheet"
            href="https://threejs.org/examples/main.css"
    />
</head>

<body>
<script id="vertexShaderWater" type="x-shader/x-vertex">

    #include <fog_pars_vertex>

    varying vec2 vUv;

    void main() {

        vUv = uv;

        #include <begin_vertex>
        #include <project_vertex>
        #include <fog_vertex>

    }
</script>

<script id="fragmentShaderWater" type="x-shader/x-fragment">

    #include <common>
    #include <packing>
    #include <fog_pars_fragment>

    varying vec2 vUv;
    uniform sampler2D tDepth;
    uniform sampler2D tDudv;
    uniform vec3 waterColor;
    uniform vec3 foamColor;
    uniform float cameraNear;
    uniform float cameraFar;
    uniform float time;
    uniform float threshold;
    uniform vec2 resolution;

    float getDepth( const in vec2 screenPosition ) {
        #if DEPTH_PACKING == 1
            return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
        #else
            return texture2D( tDepth, screenPosition ).x;
        #endif
    }

    float getViewZ( const in float depth ) {
        #if ORTHOGRAPHIC_CAMERA == 1
            return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
        #else
            return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
        #endif
    }

    const float strength = 1.0;

    void main() {

        vec2 screenUV = gl_FragCoord.xy / resolution;

        float fragmentLinearEyeDepth = getViewZ( gl_FragCoord.z );
        float linearEyeDepth = getViewZ( getDepth( screenUV ) );

        float diff = saturate( fragmentLinearEyeDepth - linearEyeDepth );

        vec2 displacement = texture2D( tDudv, ( vUv * 2.0 ) - time * 0.05 ).rg;
        displacement = ( ( displacement * 2.0 ) - 1.0 ) * strength;
        diff += displacement.x;

        gl_FragColor.rgb = mix( foamColor, waterColor, step( threshold, diff ) );
        gl_FragColor.a = 1.0;

        #include <tonemapping_fragment>
        #include <encodings_fragment>
        #include <fog_fragment>

    }
</script>

<script id="vertexShaderWaterfall" type="x-shader/x-vertex">

    #include <fog_pars_vertex>

    varying vec2 vUv;

    void main() {

        vUv = uv;

        #include <begin_vertex>
        #include <project_vertex>
        #include <fog_vertex>

    }
</script>

<script id="fragmentShaderWaterfall" type="x-shader/x-fragment">

    #include <common>
    #include <packing>
    #include <fog_pars_fragment>

    varying vec2 vUv;
    uniform sampler2D tNoise;
    uniform sampler2D tDudv;
    uniform vec3 topDarkColor;
    uniform vec3 bottomDarkColor;
    uniform vec3 topLightColor;
    uniform vec3 bottomLightColor;
    uniform vec3 foamColor;
    uniform float time;
    uniform vec2 baseSize;  // Nouvelle uniform pour la taille de base
    uniform vec2 meshSize;  // Taille actuelle du mesh

    float round( float a ) {
      return floor( a + 0.5 );
    }

    const float strength = 0.02;

    void main() {
      // Taille fixe du pattern - le motif se répète toujours à cette taille
      float patternScale = 1.0;

      // Coordonnées UV répétées sans étirement à chaque baseSize unités
      vec2 fixedScaleUV = vec2(
          vUv.x * (meshSize.x / baseSize.x),
          vUv.y * (meshSize.y / baseSize.y)
      ) * patternScale;

      // Animation de déplacement vertical continu
      float flowSpeed = 0.2;
      float flowOffset = time * flowSpeed;

      // Création de plusieurs couches avec des fréquences différentes pour éviter les répétitions visibles

      // Première couche - pattern principal
      vec2 dudvUV1 = vec2(fixedScaleUV.x, fixedScaleUV.y - flowOffset);
      vec2 displacement1 = texture2D(tDudv, dudvUV1).rg;
      displacement1 = ((displacement1 * 2.0) - 1.0) * strength;

      // Deuxième couche - pattern secondaire décalé pour l'entrelacement
      vec2 dudvUV2 = vec2(fixedScaleUV.x * 1.4 + 0.23, fixedScaleUV.y * 0.8 - flowOffset * 1.3);
      vec2 displacement2 = texture2D(tDudv, dudvUV2).rg;
      displacement2 = ((displacement2 * 2.0) - 1.0) * strength * 0.7;

      // Mélange des deux couches de déplacement
      vec2 displacement = displacement1 + displacement2;

      // Pattern de bruit animé pour l'effet de mouvement de l'eau
      vec2 noiseUV = vec2(
          fixedScaleUV.x + displacement.x,
          (fixedScaleUV.y / 5.0) - flowOffset + displacement.y
      );

      float noise = texture2D(tNoise, noiseUV).r;
      noise = round(noise * 5.0) / 5.0; // banding, values in the range [0, 0.2, 0.4, 0.6, 0.8, 1]

      // On garde le mélange de couleurs basé sur la position Y originale pour avoir un dégradé cohérent
      vec3 color = mix(mix(bottomDarkColor, topDarkColor, vUv.y), mix(bottomLightColor, topLightColor, vUv.y), noise);

      gl_FragColor.rgb = color;
      gl_FragColor.a = 1.0;

      #include <tonemapping_fragment>
      #include <encodings_fragment>
      #include <fog_fragment>
    }
</script>

<script src="src/index.js"></script>
</body>
</html>
