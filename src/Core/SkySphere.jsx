import { useLoader, useFrame, useThree } from '@react-three/fiber';
import { MeshBasicMaterial, BackSide, EquirectangularReflectionMapping } from 'three';
import { useMemo, useRef, useState, useEffect } from 'react';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';
import { EventBus } from '../Utils/EventEmitter';

const SkySphere = () => {
    const { camera } = useThree();
    const meshRef = useRef();

    // √âtat pour l'environnement actuel et forcer les re-renders
    const [currentEnvironment, setCurrentEnvironment] = useState('day');
    const [isTransitioning, setIsTransitioning] = useState(false);
    const [forceUpdate, setForceUpdate] = useState(0);

    // NOUVEAU: Configuration des seuils de progression pour chaque environnement
    const ENVIRONMENT_THRESHOLDS = {
        day: { min: 0.0, max: 0.35 },      // 0% √† 35%
        goddess: { min: 0.35, max: 0.70 }, // 35% √† 70%
        night: { min: 0.70, max: 1.0 }     // 70% √† 100%
    };

    // R√©f√©rence pour √©viter les synchronisations inutiles
    const lastSyncedEnvironment = useRef('day');
    const isInitialized = useRef(false);
    const lastScrollProgress = useRef(0);

    // Charger les trois textures d'environnement
    const dayTexture = useLoader(RGBELoader, './textures/desktop/environmentMap/dayclouds.hdr');
    const goddessTexture = useLoader(RGBELoader, './textures/desktop/environmentMap/godnessclouds.hdr');
    const nightTexture = useLoader(RGBELoader, './textures/desktop/environmentMap/nightclouds.hdr');

    // Mapper les textures par nom d'environnement
    const textures = useMemo(() => ({
        day: dayTexture,
        goddess: goddessTexture,
        night: nightTexture
    }), [dayTexture, goddessTexture, nightTexture]);

    // Configuration initiale des textures
    useEffect(() => {
        Object.values(textures).forEach(texture => {
            if (texture) {
                texture.mapping = EquirectangularReflectionMapping;
                texture.flipY = false;
                texture.needsUpdate = true;
            }
        });
        console.log('üåå SkySphere: Textures configur√©es pour les transitions (flipY=false)');
    }, [textures]);

    // NOUVEAU: Fonction pour d√©terminer l'environnement bas√© sur la progression du scroll
    const getEnvironmentFromProgress = (normalizedProgress) => {
        if (normalizedProgress >= ENVIRONMENT_THRESHOLDS.night.min) {
            return 'night';
        } else if (normalizedProgress >= ENVIRONMENT_THRESHOLDS.goddess.min) {
            return 'goddess';
        } else {
            return 'day';
        }
    };

    // Fonction pour changer d'environnement et forcer le re-render
    const changeEnvironment = (newEnvironment, source = 'unknown') => {
        if (newEnvironment !== currentEnvironment) {
            console.log(`üåå SkySphere: Changement d'environnement ${currentEnvironment} ‚Üí ${newEnvironment} (source: ${source})`);

            // √âmettre un √©v√©nement de d√©but de transition
            EventBus.trigger('environment-transition-started', {
                from: currentEnvironment,
                to: newEnvironment,
                source: source
            });

            setCurrentEnvironment(newEnvironment);
            lastSyncedEnvironment.current = newEnvironment;
            setForceUpdate(prev => prev + 1); // Force le re-render du mat√©riau

            // √âmettre un √©v√©nement de fin de transition apr√®s un court d√©lai
            setTimeout(() => {
                EventBus.trigger('environment-transition-completed', {
                    to: newEnvironment,
                    source: source
                });
            }, 100);
        }
    };

    // Cr√©er un NOUVEAU mat√©riau √† chaque changement d'environnement
    const material = useMemo(() => {
        const currentTexture = textures[currentEnvironment];
        if (!currentTexture) {
            console.warn(`üåå SkySphere: Texture non trouv√©e pour l'environnement ${currentEnvironment}`);
            return null;
        }

        // Cr√©er un nouveau mat√©riau √† chaque fois
        const newMaterial = new MeshBasicMaterial({
            map: currentTexture,
            side: BackSide,
        });

        console.log(`üåå SkySphere: NOUVEAU mat√©riau cr√©√© avec texture ${currentEnvironment}`);
        return newMaterial;
    }, [textures, currentEnvironment, forceUpdate]); // D√©pend de forceUpdate pour recr√©er

    // Mettre √† jour directement le mesh quand le mat√©riau change
    useEffect(() => {
        if (meshRef.current && material) {
            // Disposer de l'ancien mat√©riau s'il existe
            if (meshRef.current.material && meshRef.current.material !== material) {
                meshRef.current.material.dispose();
            }

            // Assigner le nouveau mat√©riau directement
            meshRef.current.material = material;
            meshRef.current.material.needsUpdate = true;

            console.log(`üåå SkySphere: Mat√©riau assign√© directement au mesh pour ${currentEnvironment}`);
        }
    }, [material, currentEnvironment]);

    // MODIFI√â: √âcouter la progression normalis√©e du scroll pour changer automatiquement d'environnement
    useEffect(() => {
        const handleTimelinePosition = (data) => {
            const { position: normalizedPosition } = data;

            // √âviter les mises √† jour trop fr√©quentes
            if (Math.abs(normalizedPosition - lastScrollProgress.current) < 0.01) {
                return;
            }

            lastScrollProgress.current = normalizedPosition;

            // D√©terminer le nouvel environnement bas√© sur la progression
            const newEnvironment = getEnvironmentFromProgress(normalizedPosition);

            // Changer l'environnement si n√©cessaire
            if (newEnvironment !== currentEnvironment && !isTransitioning) {
                console.log(`üåå SkySphere: Transition automatique √† ${(normalizedPosition * 100).toFixed(1)}% ‚Üí ${newEnvironment}`);
                changeEnvironment(newEnvironment, 'scroll-progress');
            }
        };

        const unsubscribeTimeline = EventBus.on('timeline-position-normalized', handleTimelinePosition);

        return () => {
            unsubscribeTimeline();
        };
    }, [currentEnvironment, isTransitioning]);

    // Synchronisation initiale optimis√©e avec SceneEnvironment (garde le syst√®me existant en backup)
    useEffect(() => {
        if (!isInitialized.current) {
            const checkAndSync = () => {
                if (typeof window !== 'undefined' && window.sceneEnvironment) {
                    const currentEnv = window.sceneEnvironment.getCurrentEnvironment();
                    if (currentEnv && currentEnv !== currentEnvironment) {
                        console.log(`üåå SkySphere: Synchronisation initiale avec ${currentEnv}`);
                        changeEnvironment(currentEnv, 'scene-environment-sync');
                    }
                    isInitialized.current = true;
                    return true;
                }
                return false;
            };

            if (!checkAndSync()) {
                const syncInterval = setInterval(() => {
                    if (checkAndSync()) {
                        clearInterval(syncInterval);
                    }
                }, 500);

                setTimeout(() => {
                    clearInterval(syncInterval);
                    if (!isInitialized.current) {
                        console.warn('üåå SkySphere: Timeout de synchronisation avec SceneEnvironment');
                        isInitialized.current = true;
                    }
                }, 10000);

                return () => clearInterval(syncInterval);
            }
        }
    }, [currentEnvironment]);

    // √âcouter les √©v√©nements de transition d'environnement (garde le syst√®me existant)
    useEffect(() => {
        const handleTransitionStarted = (data) => {
            console.log(`üåå SkySphere: D√©but de transition ${data.from} ‚Üí ${data.to} (source: ${data.source || 'unknown'})`);
            setIsTransitioning(true);

            // Changer imm√©diatement vers la nouvelle texture seulement si ce n'est pas notre propre √©v√©nement
            if (data.source !== 'scroll-progress') {
                changeEnvironment(data.to, 'external-event');
            }
        };

        const handleTransitionCompleted = (data) => {
            console.log(`üåå SkySphere: Transition termin√©e vers ${data.to} (source: ${data.source || 'unknown'})`);
            setIsTransitioning(false);

            // S'assurer que nous sommes dans le bon √©tat final seulement si ce n'est pas notre propre √©v√©nement
            if (data.source !== 'scroll-progress') {
                changeEnvironment(data.to, 'external-event-complete');
            }
        };

        // S'abonner aux √©v√©nements
        const unsubscribeStart = EventBus.on('environment-transition-started', handleTransitionStarted);
        const unsubscribeComplete = EventBus.on('environment-transition-completed', handleTransitionCompleted);

        return () => {
            unsubscribeStart();
            unsubscribeComplete();
        };
    }, [currentEnvironment]);

    // Mettre √† jour la position de la sph√®re pour qu'elle suive la cam√©ra
    useFrame(() => {
        if (meshRef.current && camera) {
            meshRef.current.position.copy(camera.position);
        }
    });

    // MODIFI√â: Exposer les fonctions de debug globalement avec nouvelles informations
    useEffect(() => {
        if (typeof window !== 'undefined') {
            window.skySphereDEBUG = {
                getCurrentEnvironment: () => currentEnvironment,
                isTransitioning: () => isTransitioning,
                getLastSyncedEnvironment: () => lastSyncedEnvironment.current,
                isInitialized: () => isInitialized.current,
                getTexturesStatus: () => ({
                    day: !!dayTexture,
                    goddess: !!goddessTexture,
                    night: !!nightTexture
                }),
                getCurrentMaterial: () => meshRef.current?.material,
                getCurrentTexture: () => meshRef.current?.material?.map,
                forceSync: () => {
                    if (window.sceneEnvironment) {
                        const sceneEnv = window.sceneEnvironment.getCurrentEnvironment();
                        if (sceneEnv) {
                            changeEnvironment(sceneEnv, 'force-sync');
                            console.log(`üåå SkySphere: Synchronisation forc√©e vers ${sceneEnv}`);
                        }
                    }
                },
                forceUpdateTexture: (envName) => {
                    if (textures[envName]) {
                        changeEnvironment(envName, 'force-update');
                        console.log(`üåå SkySphere: Texture forc√©e vers ${envName}`);
                    }
                },
                getMeshRef: () => meshRef.current,
                getForceUpdateCounter: () => forceUpdate,
                // NOUVEAU: Fonctions de debug pour le syst√®me bas√© sur le scroll
                getEnvironmentThresholds: () => ENVIRONMENT_THRESHOLDS,
                getEnvironmentFromProgress: (progress) => getEnvironmentFromProgress(progress),
                getCurrentScrollProgress: () => lastScrollProgress.current,
                testProgressTransition: (progress) => {
                    const env = getEnvironmentFromProgress(progress);
                    changeEnvironment(env, 'test');
                    console.log(`üåå SkySphere: Test transition √† ${(progress * 100).toFixed(1)}% ‚Üí ${env}`);
                }
            };
        }

        return () => {
            if (typeof window !== 'undefined') {
                delete window.skySphereDEBUG;
            }
        };
    }, [currentEnvironment, isTransitioning, textures, forceUpdate]);

    // Ne pas rendre si les textures ne sont pas charg√©es
    if (!dayTexture || !goddessTexture || !nightTexture) {
        console.log('üåå SkySphere: Attente des textures...');
        return null;
    }

    // Ne pas rendre si le mat√©riau n'est pas pr√™t
    if (!material) {
        console.log('üåå SkySphere: Mat√©riau non pr√™t...');
        return null;
    }

    return (
        <mesh ref={meshRef} material={material}>
            <sphereGeometry args={[37.5, 64, 64]} />
        </mesh>
    );
};

export default SkySphere;