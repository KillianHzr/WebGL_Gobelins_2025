import React, {useEffect, useRef, useState} from 'react';
import {useThree} from '@react-three/fiber';
import useStore from '../Store/useStore';
import sceneObjectManager from '../Config/SceneObjectManager';
import {EventBus, MARKER_EVENTS} from "../Utils/EventEmitter.jsx";
import {useAnimationFrame} from "../Utils/AnimationManager.js";
import {CameraAnimatorGLB} from './CameraAnimatorGLB';

const getChaptersWithDistances = () => {
    return [{
        id: 'firstStop',
        name: "Introduction",
        distance: getDistanceForChapter('firstStop'),
        completed: false
    }, {
        id: 'secondStop',
        name: "ForÃªt mystÃ©rieuse",
        distance: getDistanceForChapter('secondStop'),
        completed: false
    }, {
        id: 'thirdStop',
        name: "DÃ©couverte",
        distance: getDistanceForChapter('thirdStop'),
        completed: false
    }, {
        id: 'fourthStop',
        name: "CrÃ©atures",
        distance: getDistanceForChapter('fourthStop'),
        completed: false
    }, {
        id: 'fifthStop',
        name: "Exploration",
        distance: getDistanceForChapter('fifthStop'),
        completed: false
    }, {id: 'sixthStop', name: "Conclusion", distance: getDistanceForChapter('sixthStop'), completed: false}];
};

// Fonction pour rÃ©cupÃ©rer la distance pour un chapitre donnÃ©
const getDistanceForChapter = (chapterId) => {
    return sceneObjectManager.getChapterDistance(chapterId);
};

// Utilisation de la fonction pour initialiser les chapitres
const CHAPTERS = getChaptersWithDistances();
const ACTIVE_CHAPTERS = CHAPTERS.filter(chapter => chapter.distance !== 0 && chapter.distance !== "none" && chapter.distance !== undefined);

// ParamÃ¨tres de dÃ©filement
const MAX_SCROLL_SPEED = 0.02;
const DECELERATION = 0.95;
const MIN_VELOCITY = 0.005;
const BASE_SENSITIVITY = 0.05;
const SCROLL_NORMALIZATION_FACTOR = 0.2;

// RÃ©cupÃ©rer un paramÃ¨tre de l'URL (pour permettre de dÃ©marrer Ã  un chapitre spÃ©cifique)
const getStartChapterFromURL = () => {
    if (typeof window !== 'undefined') {
        const urlParams = new URLSearchParams(window.location.search);
        const chapterId = urlParams.get('chapter');
        if (chapterId) {
            const chapterIndex = ACTIVE_CHAPTERS.findIndex(c => c.id === chapterId);
            if (chapterIndex >= 0) {
                let cumulativeDistance = 0;
                for (let i = 0; i <= chapterIndex; i++) {
                    cumulativeDistance += ACTIVE_CHAPTERS[i].distance;
                }
                return cumulativeDistance;
            }
        }
    }
    return 0; // Position de dÃ©part par dÃ©faut
};

export default function ScrollControls({children}) {
    return <CameraController>{children}</CameraController>;
}

function CameraController({children}) {
    const savedTargetPosition = useRef(null);
    const cameraAnimatorRef = useRef(null);
    const timelinePositionRef = useRef(0);
    const timelineLengthRef = useRef(0);
    const scrollVelocity = useRef(0);
    const flickerScrollBlockTimeoutRef = useRef(null);
    const scrollBlockedAt81Ref = useRef(false);
    const has81ThresholdBeenTriggeredRef = useRef(false);

    // CORRECTION: DÃ©placer visonTriggeredRef au niveau du composant
    const visonTriggeredRef = useRef(false);
    const visonRunTriggeredRef = useRef(false);

    // MODIFIÃ‰ : Limitation du scroll arriÃ¨re avec offset de sÃ©curitÃ©
    const minAllowedPositionRef = useRef(0); // Position minimum de base (derniÃ¨re Ã©tape validÃ©e)
    const maxProgressReachedRef = useRef(0); // Position maximale atteinte par l'utilisateur
    const SCROLL_SAFETY_OFFSET = 0.0; // Offset de sÃ©curitÃ© pour Ã©viter de revenir trop prÃ¨s de l'interaction
    const validatedPositionsRef = useRef([]); // Tableau des positions validÃ©es avec leurs offsets

    // NOUVEAU : RÃ©fÃ©rence pour la derniÃ¨re position normalisÃ©e Ã©mise
    const lastEmittedNormalizedPosition = useRef(-1);

    // NOUVEAU: Flag pour indiquer si une rÃ©initialisation est en cours
    const isReinitializingRef = useRef(false);

    const [scrollDirection, setScrollDirection] = useState(0);
    const [showInteractionButton, setShowInteractionButton] = useState(false);
    const [countdown, setCountdown] = useState(null);
    const [currentCameraZ, setCurrentCameraZ] = useState(0);
    const [interactionStatus, setInteractionStatus] = useState({});
    const previousAllowScrollRef = useRef(true);
    const [currentChapter, setCurrentChapter] = useState(0);
    const [chapterTransitioning, setChapterTransitioning] = useState(false);
    const isTransitioningRef = useRef(false);
    const savedInteractionPosition = useRef(null);
    const handledInteractions = useRef(new Set());
    const scrollBackDisabledRef = useRef(false);

    // Pour suivre si l'initialisation de la camÃ©ra GLB est en cours/terminÃ©e
    const glbInitializedRef = useRef(false);

    const transitionQueue = useRef([]);
    const isProcessingTransition = useRef(false);
    const {size, camera, scene} = useThree();
    const {debug, updateDebugConfig, getDebugConfigValue, clickListener, cameraModel, cameraAnimation} = useStore();
    const [isAtEndOfScroll, setIsAtEndOfScroll] = useState(false);
    const [hasTriggeredEndSwitch, setHasTriggeredEndSwitch] = useState(false);
    const END_SCROLL_THRESHOLD = 0.85; // 92.5% du scroll considÃ©rÃ© comme fin

    const endGroupVisible = useStore(state => state.endGroupVisible);
    const screenGroupVisible = useStore(state => state.screenGroupVisible);
    const setEndGroupVisible = useStore(state => state.setEndGroupVisible);
    const setScreenGroupVisible = useStore(state => state.setScreenGroupVisible);
    const isWaitingForInteraction = useStore(state => state.interaction?.waitingForInteraction);
    const allowScroll = useStore(state => state.interaction?.allowScroll !== false);
    const interactionStep = useStore(state => state.interaction?.currentStep);
    const completeInteraction = useStore(state => state.interaction?.completeInteraction);
    const setAllowScroll = useStore(state => state.interaction?.setAllowScroll);
    const setWaitingForInteraction = useStore(state => state.interaction?.setWaitingForInteraction);
    const setCurrentStep = useStore(state => state.interaction?.setCurrentStep);
    const setInteractionTarget = useStore(state => state.interaction?.setInteractionTarget);

    // RÃ©cupÃ©rer dynamiquement les points d'interaction depuis le SceneObjectManager
    const [interactions, setInteractions] = useState([]);

    // NOUVEAU: Fonction pour extraire et appliquer les paramÃ¨tres de camÃ©ra depuis le modÃ¨le GLB
    const applyCameraParametersFromGLB = (model) => {
        if (!model || !camera) return;

        console.log("ðŸŽ¥ Extracting camera parameters from GLB model");

        try {
            // Chercher la camÃ©ra dans le modÃ¨le GLB
            let glbCamera = null;
            const scene = model.scene || model;

            scene.traverse((object) => {
                if (object.isCamera && !glbCamera) {
                    glbCamera = object;
                    console.log("ðŸŽ¥ Found camera in GLB:", object.name, "FOV:", object.fov);
                }
            });

            // Si pas de camÃ©ra trouvÃ©e, chercher un objet qui pourrait Ãªtre une camÃ©ra
            if (!glbCamera) {
                scene.traverse((object) => {
                    if (object.name && object.name.toLowerCase().includes('camera') && !glbCamera) {
                        glbCamera = object;
                        console.log("ðŸŽ¥ Found camera-like object:", object.name);
                    }
                });
            }

            if (glbCamera) {
                // Appliquer les paramÃ¨tres de la camÃ©ra GLB
                if (glbCamera.isCamera) {
                    console.log("ðŸŽ¥ Applying camera parameters from GLB:");
                    console.log("ðŸŽ¥ - FOV:", glbCamera.fov, "â†’", camera.fov);
                    console.log("ðŸŽ¥ - Near:", glbCamera.near, "â†’", camera.near);
                    console.log("ðŸŽ¥ - Far:", glbCamera.far, "â†’", camera.far);
                    console.log("ðŸŽ¥ - Aspect:", glbCamera.aspect, "â†’", camera.aspect);

                    camera.fov = glbCamera.fov || 24; // Valeur par dÃ©faut si pas de FOV
                    camera.near = glbCamera.near || 0.1;
                    camera.far = glbCamera.far || 1000;
                    camera.aspect = glbCamera.aspect || camera.aspect;
                    camera.zoom = glbCamera.zoom || 1;

                    // IMPORTANT: Mettre Ã  jour la matrice de projection
                    camera.updateProjectionMatrix();

                    console.log("ðŸŽ¥ Camera parameters applied successfully. Final FOV:", camera.fov);
                } else if (glbCamera.fov !== undefined) {
                    // Si l'objet a des propriÃ©tÃ©s de camÃ©ra mais n'est pas une vraie camÃ©ra
                    console.log("ðŸŽ¥ Applying FOV from camera-like object:", glbCamera.fov);
                    camera.fov = glbCamera.fov;
                    camera.updateProjectionMatrix();
                }
            } else {
                console.warn("ðŸŽ¥ No camera found in GLB model, using default FOV");
                camera.fov = 30; // FOV par dÃ©faut
                camera.updateProjectionMatrix();
            }
        } catch (error) {
            console.error("ðŸŽ¥ Error extracting camera parameters:", error);
            // Appliquer des valeurs par dÃ©faut en cas d'erreur
            camera.fov = 30;
            camera.updateProjectionMatrix();
        }
    };

    // NOUVEAU: Fonction pour rÃ©initialiser complÃ¨tement le systÃ¨me de camÃ©ra
    const reinitializeCameraSystem = (model) => {
        if (isReinitializingRef.current) {
            console.log("ðŸŽ¥ Camera reinitialisation already in progress, skipping...");
            return;
        }

        isReinitializingRef.current = true;
        console.log("ðŸŽ¥ REINITIALIZING CAMERA SYSTEM...");

        try {
            // 1. Nettoyer l'animateur existant s'il y en a un
            if (cameraAnimatorRef.current) {
                console.log("ðŸŽ¥ Disposing existing camera animator");
                if (typeof cameraAnimatorRef.current.dispose === 'function') {
                    cameraAnimatorRef.current.dispose();
                }
                cameraAnimatorRef.current = null;
            }

            // 2. RÃ©initialiser les rÃ©fÃ©rences
            glbInitializedRef.current = false;
            timelinePositionRef.current = 0;
            timelineLengthRef.current = 0;
            scrollVelocity.current = 0;

            // 3. RÃ©initialiser les limites de scroll
            minAllowedPositionRef.current = 0;
            maxProgressReachedRef.current = 0;
            validatedPositionsRef.current = [];

            // 4. RÃ©initialiser les triggers d'animation
            visonTriggeredRef.current = false;
            visonRunTriggeredRef.current = false;
            lastEmittedNormalizedPosition.current = -1;

            // 5. NOUVEAU: Appliquer les paramÃ¨tres de camÃ©ra depuis le modÃ¨le GLB
            applyCameraParametersFromGLB(model);

            console.log("ðŸŽ¥ Camera system reset complete, initializing with model:", model);

            // 6. Initialiser avec le nouveau modÃ¨le aprÃ¨s un court dÃ©lai
            setTimeout(() => {
                initializeGLBAnimator(model);
                isReinitializingRef.current = false;
                console.log("ðŸŽ¥ Camera system reinitialisation complete");
            }, 100);

        } catch (error) {
            console.error("ðŸŽ¥ Error during camera system reinitialisation:", error);
            isReinitializingRef.current = false;
        }
    };

    // CORRIGÃ‰ : Fonction pour calculer et Ã©mettre la position normalisÃ©e
    const emitNormalizedPosition = () => {
        if (timelineLengthRef.current > 0) {
            const normalizedPosition = Math.max(0, Math.min(1, timelinePositionRef.current / timelineLengthRef.current));

            if (Math.abs(normalizedPosition - lastEmittedNormalizedPosition.current) > 0.001) {
                lastEmittedNormalizedPosition.current = normalizedPosition;

                EventBus.trigger('timeline-position-normalized', {
                    position: normalizedPosition,
                    rawPosition: timelinePositionRef.current,
                    timelineLength: timelineLengthRef.current
                });

                const VISON_TRIGGER = 0.62;
                const SCREEN_TRIGGER = 0.23; //VisonRun

                if (normalizedPosition >= VISON_TRIGGER && !visonTriggeredRef.current) {
                    console.log("ðŸ¦¡ DÃ©clenchement animation Vison Ã  la position:", normalizedPosition);

                    visonTriggeredRef.current = true;

                    // Utiliser la nouvelle fonction globale
                    if (window.startAnimation) {
                        const success = window.startAnimation('Vison', 'animation_0');
                        console.log(`ðŸ¦¡ Animation Vison dÃ©clenchÃ©e: ${success}`);
                    }
                }
                if (normalizedPosition >= SCREEN_TRIGGER && !visonRunTriggeredRef.current) {
                    visonRunTriggeredRef.current = true;

                    // Utiliser la nouvelle fonction globale
                    if (window.startAnimation) {
                        const success = window.startAnimation('VisonRun', 'animation_0');
                        console.log(`ðŸ¦¡ Animation VisonRun dÃ©clenchÃ©e: ${success}`);
                    }
                }
            }
        }
    };

    // MODIFIÃ‰ : Fonction pour mettre Ã  jour la position minimale autorisÃ©e avec offset
    const updateMinAllowedPosition = (newPosition) => {
        if (newPosition > minAllowedPositionRef.current) {
            // Ajouter cette position Ã  la liste des positions validÃ©es
            validatedPositionsRef.current.push({
                basePosition: newPosition,
                offsetPosition: newPosition + SCROLL_SAFETY_OFFSET,
                hasPassedOffset: false // On n'a pas encore dÃ©passÃ© l'offset
            });

            minAllowedPositionRef.current = newPosition;
            console.log(`Position minimale de base mise Ã  jour : ${newPosition} (offset Ã  ${newPosition + SCROLL_SAFETY_OFFSET})`);

            // Ã‰mettre un Ã©vÃ©nement pour informer d'autres composants si nÃ©cessaire
            EventBus.trigger('min-scroll-position-updated', {
                minPosition: newPosition,
                offsetPosition: newPosition + SCROLL_SAFETY_OFFSET,
                previousMin: minAllowedPositionRef.current
            });
        }
    };

    // NOUVEAU : Fonction pour calculer la position effective de blocage
    const getEffectiveMinPosition = (currentPosition) => {
        let effectiveMin = 0; // Position minimale par dÃ©faut

        // Parcourir toutes les positions validÃ©es pour trouver la limite effective
        for (let validatedPos of validatedPositionsRef.current) {
            // Si on a dÃ©jÃ  dÃ©passÃ© l'offset de cette position, utiliser l'offset comme limite
            if (validatedPos.hasPassedOffset && validatedPos.offsetPosition > effectiveMin) {
                effectiveMin = validatedPos.offsetPosition;
            }
            // Sinon, utiliser la position de base si elle est plus Ã©levÃ©e
            else if (!validatedPos.hasPassedOffset && validatedPos.basePosition > effectiveMin) {
                effectiveMin = validatedPos.basePosition;
            }
        }

        return effectiveMin;
    };

    // NOUVEAU : Fonction pour mettre Ã  jour les flags de dÃ©passement d'offset
    const updateOffsetFlags = (currentPosition) => {
        for (let validatedPos of validatedPositionsRef.current) {
            // Si on dÃ©passe l'offset d'une position et qu'on ne l'avait pas encore marquÃ©
            if (!validatedPos.hasPassedOffset && currentPosition > validatedPos.offsetPosition) {
                validatedPos.hasPassedOffset = true;
                console.log(`Offset dÃ©passÃ© pour la position ${validatedPos.basePosition} (offset: ${validatedPos.offsetPosition})`);
            }
        }
    };

    // Fonction pour vÃ©rifier si une position est autorisÃ©e
    const isPositionAllowed = (position) => {
        const effectiveMin = getEffectiveMinPosition(position);

        // VÃ©rifier s'il y a une restriction due Ã  la flashlight
        const flashlightRestriction = validatedPositionsRef.current.find(pos => pos.reason === 'flashlight-activation');

        if (flashlightRestriction) {
            // Si la flashlight a Ã©tÃ© activÃ©e, bloquer complÃ¨tement le retour en arriÃ¨re
            return position >= flashlightRestriction.basePosition;
        }

        return position >= effectiveMin;
    };

    // Fonction pour limiter une position aux bornes autorisÃ©es
    const clampToAllowedRange = (position) => {
        const effectiveMinPos = getEffectiveMinPosition(position);
        const maxPos = timelineLengthRef.current;

        // VÃ©rifier s'il y a une restriction due Ã  la flashlight
        const flashlightRestriction = validatedPositionsRef.current.find(pos => pos.reason === 'flashlight-activation');

        if (flashlightRestriction) {
            // Si la flashlight a Ã©tÃ© activÃ©e, utiliser sa position comme minimum absolu
            const absoluteMin = flashlightRestriction.basePosition;
            return Math.max(absoluteMin, Math.min(maxPos, position));
        }

        return Math.max(effectiveMinPos, Math.min(maxPos, position));
    };

    // NOUVEAU: Ã‰couter les Ã©vÃ©nements de reload de camÃ©ra
    useEffect(() => {
        const handleCameraReload = (data) => {
            console.log("ðŸŽ¥ ScrollControls received camera reload event:", data);

            if (data && data.cameraModel) {
                console.log("ðŸŽ¥ Reinitializing camera system with reloaded model");
                reinitializeCameraSystem(data.cameraModel);
            } else {
                console.warn("ðŸŽ¥ Camera reload event received but no model provided");
            }
        };

        const handleForceReinitialize = (data) => {
            console.log("ðŸŽ¥ ScrollControls received force reinitialize event:", data);

            // Utiliser le modÃ¨le du store
            const currentModel = useStore.getState().cameraModel;
            if (currentModel) {
                console.log("ðŸŽ¥ Force reinitializing with current store model");
                reinitializeCameraSystem(currentModel);
            } else {
                console.warn("ðŸŽ¥ Force reinitialize requested but no model in store");
            }
        };

        // S'abonner aux Ã©vÃ©nements
        const reloadSubscription = EventBus.on('camera-glb-reloaded', handleCameraReload);
        const forceReinitSubscription = EventBus.on('force-reinitialize-scroll-controls', handleForceReinitialize);

        return () => {
            reloadSubscription();
            forceReinitSubscription();
        };
    }, []);

    // Ã‰couter les Ã©vÃ©nements de chargement de la camÃ©ra GLB
    useEffect(() => {
        const handleCameraGLBLoaded = (data) => {
            if (cameraModel) {
                initializeGLBAnimator(cameraModel);
            }
        };

        const handleCameraAnimationLoaded = (data) => {
            if (cameraAnimatorRef.current && data.animation) {
                // Si nÃ©cessaire, rÃ©initialiser l'animateur avec la nouvelle animation
            }
        };

        // S'abonner aux Ã©vÃ©nements
        const cameraGLBSubscription = EventBus.on('camera-glb-loaded', handleCameraGLBLoaded);
        const cameraAnimationSubscription = EventBus.on('camera-animation-loaded', handleCameraAnimationLoaded);

        return () => {
            cameraGLBSubscription();
            cameraAnimationSubscription();
        };
    }, [cameraModel]);

    // Initialiser l'animateur de camÃ©ra GLB
    const initializeGLBAnimator = (model) => {
        if (!model || glbInitializedRef.current) return;

        // Ã‰viter les rÃ©initialisations multiples
        if (isReinitializingRef.current && glbInitializedRef.current) {
            console.log("ðŸŽ¥ GLB animator already initialized and reinitialisation in progress, skipping");
            return;
        }

        try {
            console.log("ðŸŽ¥ Initializing GLB animator with model:", model);

            if (model.scene && Array.isArray(model.animations)) {
                cameraAnimatorRef.current = new CameraAnimatorGLB(model, camera, 'Action.008');
            } else {
                cameraAnimatorRef.current = new CameraAnimatorGLB(model, camera, 'Action.008');
            }

            // VÃ©rifier si l'initialisation a fonctionnÃ©
            if (cameraAnimatorRef.current.timelineLength > 0) {
                timelineLengthRef.current = cameraAnimatorRef.current.getLength();
                console.log("ðŸŽ¥ Camera animator initialized successfully, timeline length:", timelineLengthRef.current);
            } else {
                timelineLengthRef.current = 30; // Valeur par dÃ©faut de 30 secondes
                console.warn("ðŸŽ¥ Camera animator timeline length is 0, using default 30s");
            }

            // DÃ©terminer la position de dÃ©part
            const startChapterPosition = getStartChapterFromURL();
            timelinePositionRef.current = startChapterPosition;

            // CORRIGÃ‰ : Initialiser les limites de scroll correctement
            minAllowedPositionRef.current = 0; // Toujours permettre de revenir au dÃ©but initialement
            maxProgressReachedRef.current = startChapterPosition;
            validatedPositionsRef.current = []; // RÃ©initialiser le tableau des positions validÃ©es

            cameraAnimatorRef.current.setPosition(startChapterPosition);

            // NOUVEAU : Ã‰mettre la position normalisÃ©e initiale
            emitNormalizedPosition();

            // NOUVEAU : Initialiser l'UI de debug si en mode debug
            if (debug?.active) {
                setTimeout(() => {
                    createDebugUI();
                    const normalizedPos = timelineLengthRef.current > 0 ?
                        startChapterPosition / timelineLengthRef.current : 0;
                    updateDebugIndicators(startChapterPosition, normalizedPos);
                    console.log('Debug UI: InitialisÃ© avec position de dÃ©part');
                }, 100); // Petit dÃ©lai pour s'assurer que l'interface est prÃªte
            }

            // Exposer la fonction jumpToChapter globalement
            window.jumpToChapter = jumpToChapter;
            window.smoothJumpTo = smoothJumpTo;
            window.doJumpToChapter = doJumpToChapter;
            window.CHAPTERS = ACTIVE_CHAPTERS;

            // NOUVEAU : Exposer les fonctions de debug pour le systÃ¨me de scroll
            window.scrollDebug = {
                getValidatedPositions: () => validatedPositionsRef.current,
                getCurrentPosition: () => timelinePositionRef.current,
                getEffectiveMinPosition: () => getEffectiveMinPosition(timelinePositionRef.current),
                getMinAllowedPosition: () => minAllowedPositionRef.current,
                forceUpdateOffsetFlags: () => updateOffsetFlags(timelinePositionRef.current),
                getNormalizedPosition: () => timelinePositionRef.current / timelineLengthRef.current
            };

            // CrÃ©er l'interface de progression

            createDebugUI();

            // Configurer le scroll
            setupScrollHandlers();

            // Marquer comme initialisÃ©
            glbInitializedRef.current = true;

            // Informer les autres composants que l'animateur est prÃªt
            EventBus.trigger('camera-animator-ready', {
                animator: cameraAnimatorRef.current
            });

            console.log("ðŸŽ¥ GLB camera animator initialization complete");
        } catch (error) {
            console.error('Erreur lors de l\'initialisation de CameraAnimatorGLB:', error);
        }
    };

    // Initialiser l'animateur dÃ¨s que la camÃ©ra ou le modÃ¨le est disponible
    useEffect(() => {
        if (camera && cameraModel && !glbInitializedRef.current && !isReinitializingRef.current) {
            console.log("ðŸŽ¥ Camera and model available, initializing GLB animator");
            initializeGLBAnimator(cameraModel);
        }

        return () => {
            cleanupUI();
        };
    }, [camera, cameraModel]);

    // NOUVEAU : GÃ©rer l'affichage des indicateurs de debug quand le mode debug change
    useEffect(() => {
        if (debug?.active && glbInitializedRef.current) {
            // CrÃ©er l'interface de debug si elle n'existe pas
            console.log('Debug UI: Mode debug activÃ©, crÃ©ation de l\'interface');
            createDebugUI();
            // Mettre Ã  jour immÃ©diatement les indicateurs
            const normalizedPos = timelineLengthRef.current > 0 ?
                timelinePositionRef.current / timelineLengthRef.current : 0;
            updateDebugIndicators(timelinePositionRef.current, normalizedPos);
        } else if (!debug?.active) {
            // Supprimer les Ã©lÃ©ments de debug si le mode debug est dÃ©sactivÃ©
            console.log('Debug UI: Mode debug dÃ©sactivÃ©, suppression de l\'interface');
            const debugElements = ['scroll-progress-counter', 'scroll-position-details'];
            debugElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.remove();
                    console.log(`Debug UI: Ã‰lÃ©ment ${id} supprimÃ©`);
                }
            });
        }
    }, [debug?.active, glbInitializedRef.current]);

    // Fonction pour trouver un objet dans la scÃ¨ne par son nom
    const findObjectByName = (name) => {
        let targetObject = null;
        if (name && scene) {
            scene.traverse((object) => {
                if (object.name === name) {
                    targetObject = object;
                }
            });
        }
        return targetObject;
    };

    useEffect(() => {
        const handleFlashlightFirstActivation = (data) => {
            console.log('ðŸ”¦ ScrollControls: PremiÃ¨re activation de la flashlight - Enregistrement position minimale');

            // Au lieu de dÃ©sactiver complÃ¨tement le scroll arriÃ¨re,
            // enregistrer la position actuelle comme position minimale autorisÃ©e
            const currentPosition = timelinePositionRef.current;

            // Ajouter cette position Ã  la liste des positions validÃ©es avec marqueur spÃ©cial
            validatedPositionsRef.current.push({
                basePosition: currentPosition,
                offsetPosition: currentPosition + SCROLL_SAFETY_OFFSET,
                hasPassedOffset: false,
                reason: 'flashlight-activation', // Marqueur spÃ©cial pour la flashlight
                timestamp: Date.now()
            });

            // Mettre Ã  jour la position minimale
            updateMinAllowedPosition(currentPosition);

            // Ã‰mettre un Ã©vÃ©nement pour informer d'autres composants
            EventBus.trigger('scroll-back-limited-to-flashlight-position', {
                reason: 'flashlight-first-activation',
                minPosition: currentPosition,
                offsetPosition: currentPosition + SCROLL_SAFETY_OFFSET,
                timestamp: Date.now()
            });

            // Afficher un message de debug si nÃ©cessaire
            if (debug?.active) {
                console.log(`ðŸ”¦ SCROLL ARRIÃˆRE LIMITÃ‰ Ã  partir de la position ${currentPosition.toFixed(2)}`);
            }
        };

        const flashlightActivationSubscription = EventBus.on('flashlight-first-activation', handleFlashlightFirstActivation);

        return () => {
            flashlightActivationSubscription();
        };
    }, [debug]);

    useEffect(() => {
        const handleFlashlightFlickerCompletelyFinished = (data) => {
            console.log('ðŸŽ¬ Fin complÃ¨te du clignottement de la flashlight dÃ©tectÃ©e, basculement vers screenGroup');
            console.log('ðŸ”¦ DonnÃ©es du clignottement:', data);

            // Basculer de endGroup vers screenGroup UNIQUEMENT si les conditions sont bonnes
            if (endGroupVisible && !screenGroupVisible) {
                // Mettre Ã  jour le store
                setEndGroupVisible(false);
                setScreenGroupVisible(true);

                // Mettre Ã  jour directement les rÃ©fÃ©rences DOM
                if (window.endGroupRef && window.endGroupRef.current) {
                    window.endGroupRef.current.visible = false;
                    console.log('âœ… EndGroup cachÃ© (fin de clignottement)');
                }
                if (window.screenGroupRef && window.screenGroupRef.current) {
                    window.screenGroupRef.current.visible = true;
                    console.log('âœ… ScreenGroup affichÃ© (fin de clignottement)');
                }

                // Ã‰mettre les Ã©vÃ©nements
                EventBus.trigger('end-group-visibility-changed', false);
                EventBus.trigger('screen-group-visibility-changed', true);

                console.log('ðŸŽ¬ Switch synchronisÃ© avec fin de clignottement: endGroupâ†’CACHÃ‰, screenGroupâ†’VISIBLE');
            } else {
                console.log('ðŸŽ¬ Switch dÃ©jÃ  effectuÃ© ou Ã©tats inattendus:', {
                    endGroupVisible,
                    screenGroupVisible
                });
            }
        };

        // S'abonner Ã  l'Ã©vÃ©nement de fin complÃ¨te du clignottement
        const flashlightFlickerSubscription = EventBus.on('flashlight-flicker-completely-finished', handleFlashlightFlickerCompletelyFinished);

        return () => {
            flashlightFlickerSubscription();
        };
    }, [endGroupVisible, screenGroupVisible, setEndGroupVisible, setScreenGroupVisible]);

    // RÃ©cupÃ©rer les points d'interaction
    useEffect(() => {
        const interactivePlacements = sceneObjectManager.getInteractivePlacements();

        const interactionPoints = interactivePlacements.map(placement => {
            return {
                id: placement.requiredStep,
                name: placement.markerText || sceneObjectManager.getStepText(placement.requiredStep),
                triggers: {
                    x: placement.position[0], z: placement.position[2]
                },
                isActive: true,
                objectKey: placement.objectKey
            };
        });

        setInteractions(interactionPoints);
    }, []);

    useEffect(() => {
        // Fonction pour gÃ©rer les Ã©vÃ©nements d'interaction complÃ¨te
        const handleInteractionComplete = (data) => {
            // VÃ©rifier si une interface doit Ãªtre affichÃ©e
            if (data.interfaceToShow) {
                const store = useStore.getState();

                // Afficher l'interface correspondante
                switch (data.interfaceToShow) {
                    case 'scanner':
                        if (store.interaction && typeof store.interaction.setShowScannerInterface === 'function') {
                            store.interaction.setShowScannerInterface(true);
                        }
                        break;
                    case 'capture':
                        if (store.interaction && typeof store.interaction.setShowCaptureInterface === 'function') {
                            store.interaction.setShowCaptureInterface(true);
                        }
                        break;
                    case 'blackScreen':
                        if (store.interaction && typeof store.interaction.setShowBlackscreenInterface === 'function') {
                            store.interaction.setShowBlackscreenInterface(true);
                        }
                        break;
                    default:
                        console.warn(`[EventListener] Type d'interface non reconnu: ${data.interfaceToShow}`);
                }
            }
        };

        // S'abonner aux Ã©vÃ©nements d'interaction complÃ¨te
        const subscription = EventBus.on(MARKER_EVENTS.INTERACTION_COMPLETE, handleInteractionComplete);

        // Nettoyage de l'abonnement lors du dÃ©montage
        return () => {
            subscription();
        };
    }, []);

    // Fonction pour vÃ©rifier les dÃ©clencheurs d'interaction
    const checkInteractionTriggers = (position) => {
        // Variable pour stocker l'interaction dÃ©clenchÃ©e
        let triggeredInteraction = null;

        // RÃ©cupÃ©rer la liste des interactions complÃ©tÃ©es
        const completedInteractions = useStore.getState().interaction.completedInteractions || {};

        // DÃ©finir une distance maximale
        const TRIGGER_PROXIMITY = 4.75;

        // Fonction utilitaire pour vÃ©rifier les prÃ©requis d'une interaction
        const checkInteractionPrerequisites = (interaction) => {
            // Cas spÃ©cifique pour AnimalPaws (maintenu pour compatibilitÃ©)
            if (interaction.objectKey === 'AnimalPaws') {
                const leafErableCompleted = Object.keys(completedInteractions).some(key => key.includes('thirdStop') || key.includes('LeafErable'));

                if (!leafErableCompleted) {
                    return false;
                }
            }

            // VÃ©rification gÃ©nÃ©rique des prÃ©requis basÃ©e sur la configuration des objets
            const objectConfig = sceneObjectManager.getObjectFromCatalog(interaction.objectKey);

            if (objectConfig && Array.isArray(objectConfig.interaction) && objectConfig.interaction.length > 1) {
                // Trouver l'index de l'interaction actuelle
                const currentInteractionIndex = objectConfig.interaction.findIndex(config => config.requiredStep === interaction.id);

                // Si ce n'est pas la premiÃ¨re interaction (index > 0), vÃ©rifier les prÃ©requis
                if (currentInteractionIndex > 0) {
                    // Obtenir l'interaction prÃ©cÃ©dente
                    const previousInteraction = objectConfig.interaction[currentInteractionIndex - 1];

                    // VÃ©rifier si l'interaction prÃ©cÃ©dente a Ã©tÃ© complÃ©tÃ©e
                    const previousStepCompleted = Object.keys(completedInteractions).some(key => key.includes(previousInteraction.requiredStep) || key === previousInteraction.requiredStep);

                    // Si l'interaction prÃ©cÃ©dente n'a pas Ã©tÃ© complÃ©tÃ©e, ignorer cette interaction
                    if (!previousStepCompleted) {
                        return false;
                    }
                }
            }

            // Tous les prÃ©requis sont satisfaits
            return true;
        };

        interactions.forEach(interaction => {
            // Ignorer les interactions dÃ©jÃ  complÃ©tÃ©es
            if (!interaction.isActive || completedInteractions[interaction.id]) {
                return;
            }

            // VÃ©rifier les prÃ©requis avant de procÃ©der
            if (!checkInteractionPrerequisites(interaction)) {
                return;
            }

            // Calculer la distance euclidienne 2D entre la position actuelle et le point de dÃ©clenchement
            const dx = position.x - interaction.triggers.x;
            const dz = position.z - interaction.triggers.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            // Si la distance est infÃ©rieure au seuil ET que le dÃ©filement est autorisÃ©
            if (distance < TRIGGER_PROXIMITY && allowScroll && !chapterTransitioning) {
                // Stocker l'interaction dÃ©clenchÃ©e pour le log
                triggeredInteraction = interaction;

                // RÃ©cupÃ©rer l'objet associÃ© Ã  cette interaction
                const relatedObjectKey = interaction.objectKey;
                const placement = sceneObjectManager.getPlacements({
                    objectKey: relatedObjectKey, requiredStep: interaction.id
                })[0];

                // Trouver l'objet cible dans la scÃ¨ne si spÃ©cifiÃ©
                const targetObject = placement?.targetId ? findObjectByName(placement.targetId) : null;

                // Bloquer le dÃ©filement
                setAllowScroll(false);

                // Stocker la position actuelle de la timeline pour Ã©viter tout mouvement
                const currentTimelinePosition = timelinePositionRef.current;

                // Ajouter un Ã©vÃ©nement pour rÃ©tablir la position si nÃ©cessaire
                EventBus.trigger('interaction-position-saved', {
                    position: currentTimelinePosition, interactionId: interaction.id
                });

                // Indiquer que nous attendons une interaction de l'utilisateur
                setWaitingForInteraction(true);

                // Enregistrer l'Ã©tape actuelle
                setCurrentStep(interaction.id);

                // Stocker la rÃ©fÃ©rence Ã  l'objet cible dans le store
                setInteractionTarget(targetObject);

                // Mettre Ã  jour l'Ã©tat local
                setInteractionStatus(prev => ({...prev, [interaction.id]: 'waiting'}));
            }
        });

        // Afficher le log uniquement si une interaction est dÃ©clenchÃ©e
        if (triggeredInteraction) {
            // Mettre Ã  jour le chapitre actuel en fonction de l'interaction
            updateCurrentChapter();
        }
    };

    // Trouver le chapitre actuel en fonction de la position
    const updateCurrentChapter = () => {
        if (chapterTransitioning) return;

        // Utiliser la position actuelle ou sauvegardÃ©e pour le calcul
        const position = timelinePositionRef.current;
        let newChapterIndex = 0;
        let cumulativeDistance = 0;

        // Parcourir les chapitres pour dÃ©terminer lequel correspond Ã  la position actuelle
        for (let i = 0; i < ACTIVE_CHAPTERS.length; i++) {
            cumulativeDistance += ACTIVE_CHAPTERS[i].distance;
            if (position < cumulativeDistance) {
                break;
            }
            newChapterIndex = i;
        }

        if (newChapterIndex !== currentChapter) {
            setCurrentChapter(newChapterIndex);

            // Marquer les chapitres prÃ©cÃ©dents comme complÃ©tÃ©s
            const updatedACTIVE_CHAPTERS = [...ACTIVE_CHAPTERS];
            for (let i = 0; i <= newChapterIndex; i++) {
                updatedACTIVE_CHAPTERS[i].completed = true;
            }
        }
    };

    // Ajouter un Ã©couteur pour le dÃ©but d'interaction
    useEffect(() => {
        const interactionPositionSavedSubscription = EventBus.on('interaction-position-saved', (data) => {
            savedInteractionPosition.current = data.position;
        });

        const interactionCompleteSubscription = EventBus.on(MARKER_EVENTS.INTERACTION_COMPLETE, () => {
            // Ne pas rÃ©initialiser savedInteractionPosition.current ici
        });

        return () => {
            interactionPositionSavedSubscription();
            interactionCompleteSubscription();
        };
    }, []);

    // MODIFIÃ‰ : Ã‰couter les interactions complÃ©tÃ©es pour mettre Ã  jour la position minimale
    useEffect(() => {
        // Function that will be called when an interaction is completed
        const handleInteractionComplete = (data) => {
            const interactionId = data?.id || '';

            // Si cette interaction a dÃ©jÃ  Ã©tÃ© traitÃ©e, ignorer
            if (handledInteractions.current.has(interactionId)) {
                return;
            }

            // Marquer cette interaction comme traitÃ©e
            handledInteractions.current.add(interactionId);

            // RÃ©initialiser aprÃ¨s un dÃ©lai
            setTimeout(() => {
                handledInteractions.current.delete(interactionId);
            }, 2000);

            // NOUVEAU : Enregistrer la position actuelle comme nouvelle position minimale autorisÃ©e
            const currentPosition = timelinePositionRef.current;
            updateMinAllowedPosition(currentPosition);

            // Traitement simplifiÃ© pour la transition aprÃ¨s l'interaction
            setTimeout(() => {
                const stepId = interactionId.split('-')[0];
                const distanceToMove = sceneObjectManager.getChapterDistance(stepId);

                if (distanceToMove === 0) {
                    // Ajouter un Ã©vÃ©nement explicite pour informer les autres systÃ¨mes
                    EventBus.trigger('no-transition-for-step', {
                        stepId: stepId, reason: 'zero-distance'
                    });

                    // RÃ©activer le dÃ©filement aprÃ¨s un court dÃ©lai
                    setTimeout(() => {
                        if (setAllowScroll) {
                            setAllowScroll(true);
                        }
                    }, 500);

                    return;
                }

                // Calculer la position cible
                const targetPosition = currentPosition + distanceToMove;

                // Effectuer la transition
                smoothJumpTo(targetPosition);

                // Notifier les autres composants
                EventBus.trigger('post-interaction-advancement', {
                    startPosition: currentPosition,
                    distance: distanceToMove,
                    targetPosition: targetPosition,
                    stepId: stepId
                });
            }, 1000);
        };

        // Set up multiple event listeners to catch the completion event however it's emitted
        const interactionCompleteSubscription1 = EventBus.on('INTERACTION_COMPLETE', handleInteractionComplete);
        const interactionCompleteSubscription2 = EventBus.on(MARKER_EVENTS.INTERACTION_COMPLETE, handleInteractionComplete);
        const interactionCompleteSubscription3 = EventBus.on('marker:interaction:complete', handleInteractionComplete);

        // Clean up listeners on unmount
        return () => {
            interactionCompleteSubscription1();
            interactionCompleteSubscription2();
            interactionCompleteSubscription3();
        };
    }, []);

    useEffect(() => {
        // Listen for chapter jump requests from the GUI
        const guiJumpSubscription = EventBus.on('gui-chapter-jump-initiated', (data) => {
            // Check if we're currently in a transition
            if (isTransitioningRef.current) {
                // Force reset transition state
                isTransitioningRef.current = false;
                setChapterTransitioning(false);
            }

            // Find the chapter index based on name
            const chapterIndex = ACTIVE_CHAPTERS.findIndex(chapter => chapter.name === data.chapterName);
            if (chapterIndex !== -1) {
                jumpToChapter(chapterIndex);
            }
        });

        // Listen for direct transition requests
        const directTransitionSubscription = EventBus.on('direct-transition-to-position', (data) => {
            // Force reset transition state
            isTransitioningRef.current = false;
            setChapterTransitioning(false);

            // Execute the transition
            smoothJumpTo(data.position);
        });

        return () => {
            guiJumpSubscription();
            directTransitionSubscription();
        };
    }, []);

    // Fonctions pour gÃ©rer le dÃ©filement et les transitions
    const smoothJumpTo = (targetPosition) => {
        // NOUVEAU : VÃ©rifier si la position cible est autorisÃ©e avant d'ajouter Ã  la queue
        const clampedPosition = clampToAllowedRange(targetPosition);

        if (clampedPosition !== targetPosition) {
            console.log(`Position cible ${targetPosition} limitÃ©e Ã  ${clampedPosition} (position minimale: ${minAllowedPositionRef.current})`);
        }

        // Ajouter la transition Ã  la file d'attente
        transitionQueue.current.push(clampedPosition);

        // Si une transition est dÃ©jÃ  en cours, ne pas en dÃ©marrer une nouvelle
        if (isProcessingTransition.current) {
            return;
        }

        // Traiter la file d'attente de transitions
        processTransitionQueue();
    };

    // Fonction pour traiter les transitions en file d'attente une par une
    const processTransitionQueue = () => {
        // Si la file est vide, sortir
        if (transitionQueue.current.length === 0) {
            isProcessingTransition.current = false;
            return;
        }

        // Marquer qu'une transition est en cours
        isProcessingTransition.current = true;

        // RÃ©cupÃ©rer la prochaine position cible
        const targetPosition = transitionQueue.current[0];

        // NOUVEAU : VÃ©rifier encore une fois que la position est autorisÃ©e
        const finalTargetPosition = clampToAllowedRange(targetPosition);

        // DÃ©sactiver explicitement la correction de position pendant cette transition
        const savedInteractionPositionBackup = savedInteractionPosition.current;
        savedInteractionPosition.current = null;

        // Marquer le dÃ©but de la transition
        isTransitioningRef.current = true;
        setChapterTransitioning(true);

        // RÃ©initialiser la vÃ©locitÃ© de dÃ©filement
        scrollVelocity.current = 0;

        // Sauvegarder les positions et rotations de dÃ©part et d'arrivÃ©e
        const startPosition = {...camera.position.clone()};
        const startRotation = {...camera.rotation.clone()};

        // Stocker la position actuelle pour restauration
        const currentTimelinePos = timelinePositionRef.current;

        // CrÃ©er un Ã©tat temporaire pour la camÃ©ra
        const tempCamera = camera.clone();
        const originalPosition = camera.position.clone();
        const originalRotation = camera.rotation.clone();

        // Temporairement mettre Ã  jour la position
        timelinePositionRef.current = finalTargetPosition;
        // Utiliser updateCamera pour calculer la nouvelle position
        const targetCameraState = cameraAnimatorRef.current.updateCamera();

        // Restaurer la camÃ©ra Ã  sa position d'origine
        camera.position.copy(originalPosition);
        camera.rotation.copy(originalRotation);
        camera.updateMatrixWorld();

        // Restaurer la position initiale de la timeline
        timelinePositionRef.current = currentTimelinePos;

        // Maintenant nous avons les positions de dÃ©part et d'arrivÃ©e
        const endPosition = targetCameraState.position;
        const endRotation = targetCameraState.rotation;

        // DurÃ©e de la transition
        const DURATION = 2000; // 2 secondes
        const startTime = performance.now();

        // Fonction pour terminer la transition actuelle et passer Ã  la suivante
        const finishCurrentTransition = () => {
            // Important: rÃ©initialiser explicitement tous les drapeaux de transition
            isTransitioningRef.current = false;
            setChapterTransitioning(false);

            // Restaurer la position d'interaction si nÃ©cessaire
            if (savedInteractionPositionBackup !== null) {
                savedInteractionPosition.current = finalTargetPosition;
            }

            // Retirer la transition actuelle de la file
            transitionQueue.current.shift();

            // VÃ©rifier Ã  nouveau si nous pouvons traiter la file d'attente
            if (!isTransitioningRef.current && !chapterTransitioning) {
                processTransitionQueue();
            } else {
                // Forcer la rÃ©initialisation des drapeaux si toujours actifs
                isTransitioningRef.current = false;
                setChapterTransitioning(false);
                processTransitionQueue();
            }
        };

        // Fonction d'animation qui sera appelÃ©e Ã  chaque frame
        const animate = (time) => {
            // Si une interruption forcÃ©e a Ã©tÃ© demandÃ©e, il faut terminer proprement
            if (!isTransitioningRef.current) {
                // S'assurer que nous ne laissons pas la camÃ©ra dans un Ã©tat intermÃ©diaire
                timelinePositionRef.current = finalTargetPosition;
                cameraAnimatorRef.current.setPosition(finalTargetPosition);

                finishCurrentTransition();
                return;
            }

            // Calculer la progression (de 0 Ã  1)
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / DURATION, 1);

            // Interpolation linÃ©aire directe des positions
            camera.position.x = startPosition.x + (endPosition.x - startPosition.x) * progress;
            camera.position.y = startPosition.y + (endPosition.y - startPosition.y) * progress;
            camera.position.z = startPosition.z + (endPosition.z - startPosition.z) * progress;

            // Interpolation linÃ©aire des rotations
            camera.rotation.x = startRotation.x + (endRotation.x - startRotation.x) * progress;
            camera.rotation.y = startRotation.y + (endRotation.y - startRotation.y) * progress;
            camera.rotation.z = startRotation.z + (endRotation.z - startRotation.z) * progress;

            // Mettre Ã  jour la matrice de la camÃ©ra
            camera.updateMatrixWorld();

            // Mettre Ã  jour progressivement la position de la timeline
            timelinePositionRef.current = currentTimelinePos + (finalTargetPosition - currentTimelinePos) * progress;

            // NOUVEAU : Ã‰mettre la position normalisÃ©e pendant la transition
            emitNormalizedPosition();

            // Mettre Ã  jour l'indicateur visuel de progression
            updateProgressIndicator(timelinePositionRef.current);

            // Continuer l'animation jusqu'Ã  la fin
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation terminÃ©e
                // Fixer la position finale exacte
                timelinePositionRef.current = finalTargetPosition;
                cameraAnimatorRef.current.setPosition(finalTargetPosition);

                // NOUVEAU : Mettre Ã  jour le progrÃ¨s maximum atteint
                if (finalTargetPosition > maxProgressReachedRef.current) {
                    maxProgressReachedRef.current = finalTargetPosition;
                }

                // NOUVEAU : Ã‰mettre la position normalisÃ©e finale
                emitNormalizedPosition();

                // Notifier la fin de transition
                EventBus.trigger('distance-transition-complete', {
                    finalPosition: finalTargetPosition
                });

                EventBus.trigger('chapter-transition-complete', {
                    position: finalTargetPosition, finalPosition: finalTargetPosition
                });

                // Sauvegarder la position finale
                savedTargetPosition.current = finalTargetPosition;

                // Stocker la position finale comme position d'interaction uniquement si nÃ©cessaire
                if (savedInteractionPositionBackup !== null) {
                    savedInteractionPosition.current = finalTargetPosition;
                }

                // RÃ©initialiser les Ã©tats aprÃ¨s un court dÃ©lai
                setAllowScroll(true);
                setChapterTransitioning(false);
                isTransitioningRef.current = false;

                // Terminer la transition actuelle et passer Ã  la suivante
                finishCurrentTransition();
            }
        };

        // DÃ©marrer l'animation
        requestAnimationFrame(animate);
    };

    const updateProgressIndicator = (position) => {
        const timelineLength = timelineLengthRef.current;
        const progressPercentage = timelineLength > 0 ? (position / timelineLength) * 100 : 0;

        const indicator = document.getElementById('progress-indicator');
        if (indicator) {
            indicator.style.width = `${progressPercentage}%`;
        }

        // NOUVEAU : Mettre Ã  jour aussi les indicateurs de debug si actifs
        if (debug?.active && timelineLength > 0) {
            const normalizedPos = position / timelineLength;
            updateDebugIndicators(position, normalizedPos);
        }
    };

    // Fix for the jumpToChapter function
    const jumpToChapter = (index) => {
        if (index >= 0 && index < ACTIVE_CHAPTERS.length) {
            const chapter = ACTIVE_CHAPTERS[index];
            const distanceToMove = sceneObjectManager.getChapterDistance(chapter.id);

            // Si une transition est dÃ©jÃ  en cours, forcer sa rÃ©initialisation
            if (isTransitioningRef.current || chapterTransitioning) {
                // Forcer la rÃ©initialisation complÃ¨te de toutes les transitions
                EventBus.trigger('force-reset-all-transitions');

                doJumpToChapter(distanceToMove);
                return true;
            } else {
                return doJumpToChapter(distanceToMove);
            }
        } else {
            console.error(`Index de distance invalide: ${index}`);
            return false;
        }
    };

    function doJumpToChapter(distance) {
        // Sauvegarder l'Ã©tat actuel avant toute opÃ©ration
        const wasWaitingForInteraction = isWaitingForInteraction;

        // RÃ©cupÃ©rer la position actuelle comme point de dÃ©part
        const currentPosition = timelinePositionRef.current;
        // Calculer la position cible en ajoutant la distance
        const targetPosition = currentPosition + distance;

        // Si nous Ã©tions en attente d'interaction, dÃ©sactiver temporairement cet Ã©tat
        if (wasWaitingForInteraction) {
            setWaitingForInteraction(false);
        }

        // DÃ©sactiver le scroll pendant la transition
        if (setAllowScroll) {
            setAllowScroll(false);
        }

        // Nettoyer les transitions prÃ©cÃ©dentes si nÃ©cessaire
        // Vider complÃ¨tement la file d'attente existante
        transitionQueue.current = [];
        isProcessingTransition.current = false;
        isTransitioningRef.current = false;
        setChapterTransitioning(false);

        // Notifier du dÃ©but de la transition
        EventBus.trigger('distance-transition-started', {
            startPosition: currentPosition, distance: distance, targetPosition: targetPosition
        });

        // Suspendre temporairement la correction de position
        const savedInteractionPositionBackup = savedInteractionPosition.current;
        savedInteractionPosition.current = null;

        // Effectuer la transition fluide
        smoothJumpTo(targetPosition);

        return true;
    }

    // MODIFIÃ‰ : Animation frame avec limitation du scroll arriÃ¨re et Ã©mission de position
    useAnimationFrame(() => {
        if (!camera || !cameraAnimatorRef.current) return;

        const cameraPosition = {
            x: camera.position.x, y: camera.position.y, z: camera.position.z
        };

        setCurrentCameraZ(cameraPosition.z);

        // VÃ©rifier les dÃ©clencheurs d'interaction
        checkInteractionTriggers(cameraPosition);

        // 1. Calcul du mouvement - uniquement si le dÃ©filement est autorisÃ©
        if (Math.abs(scrollVelocity.current) > MIN_VELOCITY && allowScroll && !chapterTransitioning) {
            // Calculer la nouvelle position potentielle
            const potentialNewPosition = timelinePositionRef.current + scrollVelocity.current;

            // VÃ©rifier si la nouvelle position est autorisÃ©e seulement pour le mouvement arriÃ¨re
            if (scrollVelocity.current < 0) { // Mouvement arriÃ¨re
                if (isPositionAllowed(potentialNewPosition)) {
                    timelinePositionRef.current = potentialNewPosition;
                } else {
                    // Bloquer le mouvement arriÃ¨re en limitant Ã  la position effective minimale
                    const effectiveMin = getEffectiveMinPosition(timelinePositionRef.current);
                    timelinePositionRef.current = effectiveMin;
                    scrollVelocity.current = 0; // ArrÃªter la vÃ©locitÃ© pour Ã©viter les rebonds
                    console.log(`Scroll arriÃ¨re bloquÃ© Ã  la position effective ${effectiveMin}`);
                }
            } else {
                // Mouvement avant : toujours autorisÃ©
                timelinePositionRef.current = potentialNewPosition;

                // Mettre Ã  jour le progrÃ¨s maximum si on avance
                if (potentialNewPosition > maxProgressReachedRef.current) {
                    maxProgressReachedRef.current = potentialNewPosition;
                }

                // NOUVEAU : Mettre Ã  jour les flags de dÃ©passement d'offset
                updateOffsetFlags(potentialNewPosition);
            }

            // DÃ©celÃ©ration de la vÃ©locitÃ© (seulement si on n'a pas forcÃ© Ã  0)
            if (scrollVelocity.current !== 0) {
                scrollVelocity.current *= DECELERATION;
            }
        }

        // 2. Bornes et application
        if (!allowScroll && savedInteractionPosition.current !== null) {
            // Si nous sommes en interaction, forcer la position sauvegardÃ©e
            timelinePositionRef.current = savedInteractionPosition.current;
        } else {
            // MODIFIÃ‰ : Limiter la position dans les bornes autorisÃ©es (pas seulement 0 Ã  max)
            timelinePositionRef.current = clampToAllowedRange(timelinePositionRef.current);
        }

        // 3. Toujours appliquer la position au CameraAnimator
        cameraAnimatorRef.current.setPosition(timelinePositionRef.current);

        // NOUVEAU : Ã‰mettre la position normalisÃ©e Ã  chaque frame
        emitNormalizedPosition();

        // Mettre Ã  jour l'indicateur de progression (qui inclut les indicateurs de debug)
        updateProgressIndicator(timelinePositionRef.current);

        // DÃ©tection de la fin du scroll
        const scrollProgress = timelinePositionRef.current / timelineLengthRef.current;
        if (scrollProgress >= 0.81 && !has81ThresholdBeenTriggeredRef.current) {
            console.log('ðŸš« Scroll bloquÃ© Ã  81% pendant 2 secondes');
            has81ThresholdBeenTriggeredRef.current = true;
            scrollBlockedAt81Ref.current = true;

            setTimeout(() => {
                console.log('âœ… Scroll dÃ©bloquÃ© aprÃ¨s 2 secondes');
                scrollBlockedAt81Ref.current = false;
            }, 2000);
        }
        const isNowAtEnd = scrollProgress >= END_SCROLL_THRESHOLD;

        // Mettre Ã  jour l'Ã©tat uniquement s'il change pour Ã©viter des re-rendus inutiles
        if (isNowAtEnd !== isAtEndOfScroll) {
            setIsAtEndOfScroll(isNowAtEnd);
        }

        // Faire le switch seulement quand on atteint la fin du scroll pour la premiÃ¨re fois
        // if (isNowAtEnd && !hasTriggeredEndSwitch) {
        //     console.log('ðŸŽ¬ Fin du scroll dÃ©tectÃ©e, basculement vers screenGroup');
        //
        //     // Basculer de endGroup vers screenGroup
        //     if (endGroupVisible && !screenGroupVisible) {
        //         // Mettre Ã  jour le store
        //         setEndGroupVisible(false);
        //         setScreenGroupVisible(true);
        //
        //         // Mettre Ã  jour directement les rÃ©fÃ©rences DOM
        //         if (window.endGroupRef && window.endGroupRef.current) {
        //             window.endGroupRef.current.visible = false;
        //             console.log('âœ… EndGroup cachÃ©');
        //         }
        //         if (window.screenGroupRef && window.screenGroupRef.current) {
        //             window.screenGroupRef.current.visible = true;
        //             console.log('âœ… ScreenGroup affichÃ©');
        //         }
        //
        //         // Ã‰mettre les Ã©vÃ©nements
        //         EventBus.trigger('end-group-visibility-changed', false);
        //         EventBus.trigger('screen-group-visibility-changed', true);
        //
        //         console.log('ðŸŽ¬ Switch terminÃ©: endGroupâ†’CACHÃ‰, screenGroupâ†’VISIBLE');
        //     }
        //
        //     setHasTriggeredEndSwitch(true);
        //
        //     // RÃ©initialiser le dÃ©clencheur aprÃ¨s un dÃ©lai
        //     setTimeout(() => {
        //         setHasTriggeredEndSwitch(false);
        //     }, 3000);
        // }

    }, 'camera');

    // Fonction pour configurer les gestionnaires d'Ã©vÃ©nements de dÃ©filement
    const setupScrollHandlers = () => {
        let lastWheelTimestamp = 0;
        let recentWheelEvents = [];
        const MAX_WHEEL_SAMPLES = 5;

        const normalizeWheelDelta = (e) => {
            const now = performance.now();
            recentWheelEvents.push({
                deltaY: e.deltaY, timestamp: now, deltaMode: e.deltaMode
            });

            if (recentWheelEvents.length > MAX_WHEEL_SAMPLES) {
                recentWheelEvents.shift();
            }

            const timeDelta = lastWheelTimestamp ? now - lastWheelTimestamp : 0;
            lastWheelTimestamp = now;

            let normalizedDelta;

            if (e.deltaMode === 1) {
                normalizedDelta = e.deltaY * 20;
            } else if (e.deltaMode === 2) {
                normalizedDelta = e.deltaY * 500;
            } else {
                normalizedDelta = e.deltaY;
            }

            const isHighPrecision = e.deltaMode === 0 && Math.abs(normalizedDelta) < 10;

            if (isHighPrecision) {
                normalizedDelta *= 2;
            }

            const timeCoefficient = timeDelta > 0 && timeDelta < 100 ? 100 / timeDelta : 1;

            return normalizedDelta * SCROLL_NORMALIZATION_FACTOR * Math.min(timeCoefficient, 2);
        };

        let touchStartY = 0;
        let lastTouchY = 0;

        const handleTouchStart = (e) => {
            if (!allowScroll || chapterTransitioning) return;
            touchStartY = e.touches[0].clientY;
            lastTouchY = touchStartY;
        };

        const handleTouchMove = (e) => {
            if (scrollBlockedAt81Ref.current) {
                e.preventDefault();
                return;
            }

            if (!allowScroll || chapterTransitioning) return;

            const currentY = e.touches[0].clientY;
            const deltaY = lastTouchY - currentY;
            lastTouchY = currentY;

            const direction = Math.sign(deltaY);

            // Si le scroll arriÃ¨re est dÃ©sactivÃ© et qu'on essaie de scroller vers l'arriÃ¨re, ignorer complÃ¨tement
            if (scrollBackDisabledRef.current && direction > 0) { // direction > 0 = swipe vers le haut = scroll arriÃ¨re
                console.log('ðŸš« Touch scroll arriÃ¨re ignorÃ© - flashlight activÃ©e');
                e.preventDefault();
                return; // Sortir complÃ¨tement, ne pas traiter l'Ã©vÃ©nement
            }

            const magnitude = Math.abs(deltaY) * BASE_SENSITIVITY * 1.5;
            const cappedMagnitude = Math.min(magnitude, MAX_SCROLL_SPEED);

            // VÃ©rifier si le mouvement arriÃ¨re est autorisÃ©
            if (direction < 0) { // Scroll arriÃ¨re
                const potentialPosition = timelinePositionRef.current + (direction * cappedMagnitude);
                if (!isPositionAllowed(potentialPosition)) {
                    // Bloquer le mouvement arriÃ¨re
                    return;
                }
            }

            scrollVelocity.current = direction * cappedMagnitude;

            e.preventDefault();
        };

        const handleWheel = (e) => {
            if (scrollBlockedAt81Ref.current) {
                e.preventDefault();
                return;
            }

            if (!allowScroll || chapterTransitioning) {
                console.log('ðŸš« Scroll bloquÃ©:', {
                    allowScroll,
                    chapterTransitioning,
                    reason: !allowScroll ? 'scroll-disabled' : 'chapter-transitioning'
                });
                e.preventDefault();
                return;
            }

            const normalizedDelta = normalizeWheelDelta(e);
            const direction = Math.sign(normalizedDelta);
            setScrollDirection(direction);

            if (scrollBackDisabledRef.current && direction < 0) {
                console.log('ðŸš« Scroll arriÃ¨re ignorÃ© - flashlight activÃ©e');
                e.preventDefault();
                return;
            }

            let scrollMagnitude = Math.abs(normalizedDelta) * BASE_SENSITIVITY;
            const cappedMagnitude = Math.min(scrollMagnitude, MAX_SCROLL_SPEED);

            // VÃ©rifier si le mouvement arriÃ¨re est autorisÃ©
            if (direction < 0) { // Scroll arriÃ¨re
                const potentialPosition = timelinePositionRef.current + (direction * cappedMagnitude);
                if (!isPositionAllowed(potentialPosition)) {
                    e.preventDefault();
                    return;
                }
            }

            scrollVelocity.current = direction * cappedMagnitude;
            e.preventDefault();
        };

        const canvasElement = document.querySelector('canvas');
        if (canvasElement) {
            canvasElement.addEventListener('wheel', handleWheel, {passive: false});
            canvasElement.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvasElement.addEventListener('touchmove', handleTouchMove, {passive: false});
        }
    };

    // CrÃ©er UI pour les progrÃ¨s gÃ©nÃ©raux
    const createProgressUI = () => {
        // Barre de progression en bas de l'Ã©cran
        if (!document.getElementById('timeline-progress')) {
            const progressBar = document.createElement('div');
            progressBar.id = 'timeline-progress';
            progressBar.style.position = 'fixed';
            progressBar.style.bottom = '10px';
            progressBar.style.left = '10px';
            progressBar.style.right = '10px';
            progressBar.style.height = '4px';
            progressBar.style.backgroundColor = 'rgba(255,255,255,0.2)';
            progressBar.style.borderRadius = '2px';
            progressBar.style.zIndex = '100';

            const progressIndicator = document.createElement('div');
            progressIndicator.id = 'progress-indicator';
            progressIndicator.style.height = '100%';
            progressIndicator.style.width = '0%';
            progressIndicator.style.backgroundColor = 'white';
            progressIndicator.style.borderRadius = '2px';
            progressIndicator.style.transition = 'width 0.05s ease-out';

            progressBar.appendChild(progressIndicator);
            document.body.appendChild(progressBar);
            console.log('UI: Barre de progression crÃ©Ã©e');
        }
    };

    // NOUVEAU : CrÃ©er UI pour le debug en mode dÃ©veloppeur
    const createDebugUI = () => {
        if (!debug?.active) return;

        // Compteur de progression en bas Ã  gauche
        if (!document.getElementById('scroll-progress-counter')) {
            const progressCounter = document.createElement('div');
            progressCounter.id = 'scroll-progress-counter';
            progressCounter.style.position = 'fixed';
            progressCounter.style.bottom = '20px';
            progressCounter.style.right = '20px';
            progressCounter.style.padding = '12px 16px';
            progressCounter.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            progressCounter.style.color = '#00ff88';
            progressCounter.style.fontFamily = 'Monaco, "Lucida Console", monospace';
            progressCounter.style.fontSize = '16px';
            progressCounter.style.fontWeight = 'bold';
            progressCounter.style.borderRadius = '8px';
            progressCounter.style.border = '2px solid rgba(0, 255, 136, 0.3)';
            progressCounter.style.zIndex = '150';
            progressCounter.style.minWidth = '180px';
            progressCounter.style.textAlign = 'center';
            progressCounter.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.5)';
            progressCounter.style.backdropFilter = 'blur(4px)';
            progressCounter.textContent = '0.0%';
            document.body.appendChild(progressCounter);
        }

        // Indicateur de position absolue (optionnel, plus dÃ©taillÃ©)
        if (!document.getElementById('scroll-position-details')) {
            const positionDetails = document.createElement('div');
            positionDetails.id = 'scroll-position-details';
            positionDetails.style.position = 'fixed';
            positionDetails.style.bottom = '70px';
            positionDetails.style.right = '20px';
            positionDetails.style.padding = '8px 12px';
            positionDetails.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            positionDetails.style.color = '#cccccc';
            positionDetails.style.fontFamily = 'Monaco, "Lucida Console", monospace';
            positionDetails.style.fontSize = '12px';
            positionDetails.style.borderRadius = '4px';
            positionDetails.style.border = '1px solid rgba(255, 255, 255, 0.2)';
            positionDetails.style.zIndex = '149';
            positionDetails.style.maxWidth = '250px';
            positionDetails.style.wordWrap = 'break-word';
            positionDetails.innerHTML = 'Pos: 0.00 / 0.00<br>Min: 0.00';
            document.body.appendChild(positionDetails);
        }
    };

    // NOUVEAU : Mettre Ã  jour les indicateurs de debug
    const updateDebugIndicators = (currentPosition, normalizedPosition) => {
        if (!debug?.active) return;

        // Mettre Ã  jour le compteur de progression principal
        const progressCounter = document.getElementById('scroll-progress-counter');
        if (progressCounter) {
            const percentage = (normalizedPosition * 100).toFixed(1);
            progressCounter.textContent = `${percentage}%`;

            // Changer la couleur en fonction du progrÃ¨s
            if (normalizedPosition < 0.2) {
                progressCounter.style.color = '#ff6b6b'; // Rouge pour dÃ©but
                progressCounter.style.borderColor = 'rgba(255, 107, 107, 0.3)';
            } else if (normalizedPosition < 0.6) {
                progressCounter.style.color = '#ffd93d'; // Jaune pour milieu
                progressCounter.style.borderColor = 'rgba(255, 217, 61, 0.3)';
            } else {
                progressCounter.style.color = '#00ff88'; // Vert pour fin
                progressCounter.style.borderColor = 'rgba(0, 255, 136, 0.3)';
            }
        }

        // Mettre Ã  jour les dÃ©tails de position
        const positionDetails = document.getElementById('scroll-position-details');
        if (positionDetails) {
            const timelineLength = timelineLengthRef.current;
            const effectiveMin = getEffectiveMinPosition(currentPosition);
            positionDetails.innerHTML =
                `Pos: ${currentPosition.toFixed(2)} / ${timelineLength.toFixed(2)}<br>` +
                `Min: ${effectiveMin.toFixed(2)} | Max: ${maxProgressReachedRef.current.toFixed(2)}`;
        }
    };

    const cleanupUI = () => {
        // Supprimer tous les Ã©lÃ©ments d'interface crÃ©Ã©s
        [
            'scroll-debug-indicator',
            'interaction-button',
            'countdown-element',
            'timeline-progress',
            'interaction-instruction',
            'chapter-navigation',
            'scroll-progress-counter',      // NOUVEAU
            'scroll-position-details'       // NOUVEAU
        ].forEach(id => {
            const element = document.getElementById(id);
            if (element) element.remove();
        });

        // Nettoyer les Ã©couteurs d'Ã©vÃ©nements
        const canvasElement = document.querySelector('canvas');
        if (canvasElement) {
            // Note: Ces gestionnaires sont dÃ©finis dans setupScrollHandlers,
            // nous devrions idÃ©alement les stocker dans des refs pour un nettoyage prÃ©cis
            canvasElement.removeEventListener('wheel', () => {
            });
            canvasElement.removeEventListener('touchstart', () => {
            });
            canvasElement.removeEventListener('touchmove', () => {
            });
        }
    };

    return (<>
        {children}
    </>);
}